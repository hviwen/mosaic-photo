## 马赛克照片编辑器 - 优化调整需求

请按照以下优化需求修改代码：

### 优化 1：导入时智能裁剪优化

**目标：** 根据照片原始宽高比决定是否进行智能裁剪

**具体要求：**
- **竖图**（imageHeight > imageWidth）：
  - 如果原图宽高比 > 1.5（即高/宽 > 6:4），则进行智能裁剪，将裁剪后的比例限制在 ≤ 1.5
  - 如果原图宽高比 ≤ 1.5，则不进行智能裁剪，直接使用完整原图尺寸进行缩放
  
- **横图**（imageWidth > imageHeight）：
  - 如果原图宽高比 < 0.667（即宽/高 > 4:6），则进行智能裁剪，将裁剪后的比例限制在 ≥ 0.667
  - 如果原图宽高比 ≥ 0.667，则不进行智能裁剪，直接使用完整原图尺寸进行缩放

- **人脸保护：** 如果检测到人脸，确保人脸区域在裁剪后的可见尺寸不小于 100×100 像素（宽高各不小于 100px）

**涉及文件：**
- `src/utils/smartCrop.ts` - `calculateSmartCrop()` 函数
- `src/composables/useLayout.ts` - `fillArrangePhotos()` 函数中调用 `centerCropToAspect()` 的逻辑

---

### 优化 2：布局策略 - 中心放置比例接近 1:1 的照片

**目标：** 优化视觉效果，将长宽比例接近正方形的照片放置在画布中心，长条形照片放置在四周

**具体要求：**
1. 计算每张照片的宽高比偏离度：`deviation = Math.abs(Math.log(photoAspect))`（越接近 0 表示越接近 1:1）
2. 对 tiles 按到画布中心的距离排序（从中心到边缘）
3. 匹配策略：
   - 中心 tiles 优先分配给宽高比接近 1:1 的照片（`deviation` 小的）
   - 边缘 tiles 分配给长条形照片（`deviation` 大的）
4. 保持现有的"宽高比匹配"逻辑，在此基础上叠加"中心优先"策略

**涉及文件：**
- `src/composables/useLayout.ts` - `fillArrangePhotos()` 函数的贪心匹配逻辑
- `src/workers/layoutWorker.ts` - `fillArrangePhotosWorker()` 函数（需同步修改）

---

### 优化 3：排版算法优化 - 消除空隙和叠压

**目标：** 确保照片之间无缝拼接，无空隙、无重叠

**当前问题：**
- 导入照片后，相邻照片之间出现空隙或相互叠压

**期望行为：**
- 使用 `fillArrangePhotos()` 的铺满式布局算法，确保：
  - 所有照片无重叠
  - 相邻照片之间无间隔（上下左右紧密相邻）
  - 所有照片铺满整个画布，无空白区域

**排查方向：**
- 检查 `src/composables/useLayout.ts` 中 `fillArrangePhotos()` 的 tile 切分逻辑
- 验证 `drawPhoto()` 函数中照片的绘制位置和尺寸计算是否正确
- 确认 `padding` 参数是否设置为 0（铺满式布局不应有间距）

**涉及文件：**
- `src/composables/useLayout.ts` - `fillArrangePhotos()` 函数
- `src/workers/layoutWorker.ts` - `fillArrangePhotosWorker()` 函数
- `src/components/CanvasStage.vue` - `drawPhoto()` 函数

---

### 优化 4：智能排版缩放优化 - 控制缩放范围

**目标：** 避免照片缩放过小或过大，保持合理的显示尺寸

**具体要求：**
1. 在 `fillArrangePhotos()` 函数中，为每张照片的 `scale` 值设置合理范围：
   - 最小缩放：`minScale = 0.1`（避免照片过小看不清）
   - 最大缩放：`maxScale = 2.0`（避免照片过度放大导致模糊）
   
2. 在计算 placement 时，确保 `scale` 值在此范围内：
   ```typescript
   scale = Math.max(minScale, Math.min(maxScale, calculatedScale))
   ```

**涉及文件：**
- `src/composables/useLayout.ts` - `fillArrangePhotos()` 函数中 placement 的 scale 计算
- `src/workers/layoutWorker.ts` - `fillArrangePhotosWorker()` 函数（需同步修改）

---

### 优化 5：画布填充优化 - 完全填充无溢出

**目标：** 确保导入的照片完全填充画布，边缘无空白、无溢出（方便打印）

**具体要求：**
1. **完全填充：**
   - 所有导入的照片必须铺满整个画布（canvasW × canvasH）
   - 画布内部不能有任何空白区域
   
2. **边缘对齐：**
   - 上下左右四边必须被照片边缘完全填充
   - 照片不能超出画布边界（`cx ± width/2` 不能超出 `[0, canvasW]`，`cy ± height/2` 不能超出 `[0, canvasH]`）
   - 照片边缘与画布边缘之间不能有空隙

3. **实现策略：**
   - 使用 `fillArrangePhotos()` 的 tile 切分算法，确保 tiles 完全覆盖画布
   - 验证每个 tile 的边界与画布边界对齐（第一行 `y=0`，最后一行 `y+h=canvasH`，第一列 `x=0`，最后一列 `x+w=canvasW`）
   - 在 `drawPhoto()` 中添加边界检查，确保照片不超出画布

**涉及文件：**
- `src/composables/useLayout.ts` - `fillArrangePhotos()` 函数的 tile 切分和边界对齐逻辑
- `src/workers/layoutWorker.ts` - `fillArrangePhotosWorker()` 函数（需同步修改）
- `src/components/CanvasStage.vue` - `drawPhoto()` 函数的边界裁剪逻辑

---

## 验证步骤

完成优化后，请验证：

1. **优化 1 验证：** 导入宽高比 > 6:4 的竖图和宽高比 > 4:6 的横图，确认进行了智能裁剪；导入宽高比在范围内的照片，确认未裁剪
2. **优化 2 验证：** 导入混合比例照片（正方形、横图、竖图），观察布局，确认正方形照片更多出现在中心
3. **优化 3 验证：** 导入多张照片，检查画布中是否存在空隙或叠压
4. **优化 4 验证：** 导入大量照片，检查是否有照片过小或过大
5. **优化 5 验证：** 检查画布四边是否完全填充，无空白、无溢出