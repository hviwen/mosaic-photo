# ğŸ¤– æ™ºèƒ½å¸ƒå±€ä¸è®¾è®¡ - è¯¦ç»†å®ç°æ–¹æ¡ˆ

## 4. AI å¸ƒå±€åŠ©æ‰‹

### ğŸ“‹ å®ç°æ€è·¯

```
ç”¨æˆ·ä¸Šä¼ ç…§ç‰‡ â†’ æå–å›¾åƒç‰¹å¾ â†’ AI åˆ†æå†…å®¹ â†’ è®¡ç®—å¸ƒå±€æ–¹æ¡ˆ â†’ æ¨è+å¯è§†åŒ–
```

### ğŸ”§ æŠ€æœ¯æ ˆ

#### **æ–¹æ¡ˆ A: è½»é‡çº§ï¼ˆçº¯å‰ç«¯ï¼‰**

```bash
pnmp install @tensorflow/tfjs @tensorflow-models/coco-ssd
pnmp install @mediapipe/tasks-vision
```

```typescript
// 1. ç‰©ä½“æ£€æµ‹ - è¯†åˆ«ç…§ç‰‡ä¸­çš„ä¸»ä½“ä½ç½®
import * as cocoSsd from '@tensorflow-models/coco-ssd';
import '@tensorflow/tfjs';

interface PhotoAnalysis {
  imageId: string;
  subjects: Array<{
    class: string;
    bbox: [number, number, number, number]; // [x, y, width, height]
    score: number;
  }>;
  dominantColors: string[];
  aspectRatio: number;
  safeZone: { x: number; y: number; width: number; height: number };
}

class LayoutAssistant {
  private model: cocoSsd.ObjectDetection | null = null;

  async init() {
    this.model = await cocoSsd.load();
  }

  // åˆ†æå•å¼ ç…§ç‰‡
  async analyzePhoto(imageElement: HTMLImageElement): Promise<PhotoAnalysis> {
    if (!this.model) await this.init();
    
    // æ£€æµ‹ç‰©ä½“
    const predictions = await this.model!.detect(imageElement);
    
    // è®¡ç®—å®‰å…¨åŒºåŸŸï¼ˆåŒ…å«æ‰€æœ‰é‡è¦ä¸»ä½“çš„æœ€å°çŸ©å½¢ï¼‰
    const safeZone = this.calculateSafeZone(predictions);
    
    // æå–ä¸»è‰²è°ƒ
    const dominantColors = await this.extractDominantColors(imageElement);
    
    return {
      imageId: crypto.randomUUID(),
      subjects: predictions.map(p => ({
        class: p.class,
        bbox: p.bbox as [number, number, number, number],
        score: p.score
      })),
      dominantColors,
      aspectRatio: imageElement.width / imageElement.height,
      safeZone
    };
  }

  // è®¡ç®—å®‰å…¨åŒºåŸŸ
  private calculateSafeZone(predictions: any[]) {
    if (predictions.length === 0) {
      return { x: 0, y: 0, width: 1, height: 1 };
    }

    let minX = Infinity, minY = Infinity;
    let maxX = 0, maxY = 0;

    predictions.forEach(p => {
      const [x, y, width, height] = p.bbox;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + width);
      maxY = Math.max(maxY, y + height);
    });

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  // ç”Ÿæˆå¸ƒå±€æ–¹æ¡ˆ
  generateLayouts(analyses: PhotoAnalysis[], canvasSize: { width: number; height: number }) {
    const layouts: LayoutSuggestion[] = [];

    // å¸ƒå±€ç®—æ³• 1: ç½‘æ ¼å¸ƒå±€ï¼ˆé€‚åˆç…§ç‰‡æ•°é‡è¾ƒå¤šï¼‰
    if (analyses.length >= 4) {
      layouts.push(this.createGridLayout(analyses, canvasSize));
    }

    // å¸ƒå±€ç®—æ³• 2: é»„é‡‘åˆ†å‰²ï¼ˆé€‚åˆ 2-3 å¼ ç…§ç‰‡ï¼‰
    if (analyses.length <= 3) {
      layouts.push(this.createGoldenRatioLayout(analyses, canvasSize));
    }

    // å¸ƒå±€ç®—æ³• 3: æ‚å¿—é£æ ¼ï¼ˆä¸è§„åˆ™æ’åˆ—ï¼‰
    layouts.push(this.createMagazineLayout(analyses, canvasSize));

    // å¸ƒå±€ç®—æ³• 4: ç„¦ç‚¹å¸ƒå±€ï¼ˆä¸€å¼ å¤§å›¾ + å°å›¾ç¯ç»•ï¼‰
    if (analyses.length >= 2) {
      layouts.push(this.createFocalLayout(analyses, canvasSize));
    }

    // æ ¹æ®ç…§ç‰‡ç‰¹å¾è¯„åˆ†
    return layouts.map(layout => ({
      ...layout,
      score: this.scoreLayout(layout, analyses)
    })).sort((a, b) => b.score - a.score);
  }

  // é»„é‡‘åˆ†å‰²å¸ƒå±€
  private createGoldenRatioLayout(
    analyses: PhotoAnalysis[], 
    canvasSize: { width: number; height: number }
  ): LayoutSuggestion {
    const PHI = 1.618; // é»„é‡‘æ¯”ä¾‹
    const positions: PhotoPosition[] = [];

    if (analyses.length === 2) {
      // å·¦å³åˆ†å‰²
      const divideX = canvasSize.width / PHI;
      
      positions.push({
        imageId: analyses[0].imageId,
        x: 0,
        y: 0,
        width: divideX,
        height: canvasSize.height,
        rotation: 0,
        zIndex: 1
      });

      positions.push({
        imageId: analyses[1].imageId,
        x: divideX,
        y: 0,
        width: canvasSize.width - divideX,
        height: canvasSize.height,
        rotation: 0,
        zIndex: 1
      });
    } else if (analyses.length === 3) {
      // ä¸Šä¸‹åˆ†å‰² + å³ä¾§å†åˆ†å‰²
      const divideX = canvasSize.width / PHI;
      const divideY = canvasSize.height / PHI;

      positions.push({
        imageId: analyses[0].imageId,
        x: 0,
        y: 0,
        width: divideX,
        height: canvasSize.height,
        rotation: 0,
        zIndex: 1
      });

      positions.push({
        imageId: analyses[1].imageId,
        x: divideX,
        y: 0,
        width: canvasSize.width - divideX,
        height: divideY,
        rotation: 0,
        zIndex: 1
      });

      positions.push({
        imageId: analyses[2].imageId,
        x: divideX,
        y: divideY,
        width: canvasSize.width - divideX,
        height: canvasSize.height - divideY,
        rotation: 0,
        zIndex: 1
      });
    }

    return {
      name: 'Golden Ratio',
      description: 'åŸºäºé»„é‡‘åˆ†å‰²æ¯”ä¾‹çš„ç»å…¸å¸ƒå±€',
      positions,
      style: 'golden',
      score: 0
    };
  }

  // æ‚å¿—é£æ ¼å¸ƒå±€
  private createMagazineLayout(
    analyses: PhotoAnalysis[], 
    canvasSize: { width: number; height: number }
  ): LayoutSuggestion {
    const positions: PhotoPosition[] = [];
    const padding = 20;
    const overlap = 0.1; // 10% é‡å 

    // éšæœºä½†æœ‰è§„å¾‹çš„æ’åˆ—
    analyses.forEach((analysis, index) => {
      const baseSize = canvasSize.width / (Math.sqrt(analyses.length) + 0.5);
      const size = baseSize * (0.8 + Math.random() * 0.4);
      
      // ä½¿ç”¨ Poisson Disk Sampling é¿å…è¿‡åº¦é‡å 
      const x = (index % 3) * (canvasSize.width / 3) + (Math.random() - 0.5) * 50;
      const y = Math.floor(index / 3) * (canvasSize.height / 3) + (Math.random() - 0.5) * 50;
      
      positions.push({
        imageId: analysis.imageId,
        x: Math.max(0, Math.min(x, canvasSize.width - size)),
        y: Math.max(0, Math.min(y, canvasSize.height - size)),
        width: size,
        height: size / analysis.aspectRatio,
        rotation: (Math.random() - 0.5) * 10, // -5Â° åˆ° +5Â°
        zIndex: index + 1
      });
    });

    return {
      name: 'Magazine Style',
      description: 'ä¸è§„åˆ™æ’åˆ—ï¼Œé€‚åˆåˆ›æ„å±•ç¤º',
      positions,
      style: 'magazine',
      score: 0
    };
  }

  // ç„¦ç‚¹å¸ƒå±€
  private createFocalLayout(
    analyses: PhotoAnalysis[], 
    canvasSize: { width: number; height: number }
  ): LayoutSuggestion {
    const positions: PhotoPosition[] = [];
    
    // é€‰æ‹©æœ€é‡è¦çš„ç…§ç‰‡ä½œä¸ºç„¦ç‚¹ï¼ˆåŒ…å«æœ€å¤šä¸»ä½“æˆ–æœ€é«˜åˆ†ï¼‰
    const focalIndex = analyses.reduce((maxIdx, curr, idx, arr) => 
      curr.subjects.length > arr[maxIdx].subjects.length ? idx : maxIdx
    , 0);

    const focalPhoto = analyses[focalIndex];
    const others = analyses.filter((_, idx) => idx !== focalIndex);

    // ç„¦ç‚¹ç…§ç‰‡å æ® 60% ç©ºé—´
    const focalWidth = canvasSize.width * 0.6;
    const focalHeight = canvasSize.height * 0.9;

    positions.push({
      imageId: focalPhoto.imageId,
      x: 20,
      y: (canvasSize.height - focalHeight) / 2,
      width: focalWidth,
      height: focalHeight,
      rotation: 0,
      zIndex: 2
    });

    // å…¶ä»–ç…§ç‰‡åœ¨å³ä¾§çºµå‘æ’åˆ—
    const sideWidth = canvasSize.width - focalWidth - 60;
    const sideHeight = (canvasSize.height - (others.length + 1) * 20) / others.length;

    others.forEach((photo, index) => {
      positions.push({
        imageId: photo.imageId,
        x: focalWidth + 40,
        y: 20 + index * (sideHeight + 20),
        width: sideWidth,
        height: sideHeight,
        rotation: 0,
        zIndex: 1
      });
    });

    return {
      name: 'Focal Point',
      description: 'çªå‡ºä¸»ç…§ç‰‡ï¼Œå…¶ä»–ç…§ç‰‡ç¯ç»•',
      positions,
      style: 'focal',
      score: 0
    };
  }

  // ç½‘æ ¼å¸ƒå±€
  private createGridLayout(
    analyses: PhotoAnalysis[], 
    canvasSize: { width: number; height: number }
  ): LayoutSuggestion {
    const positions: PhotoPosition[] = [];
    const cols = Math.ceil(Math.sqrt(analyses.length));
    const rows = Math.ceil(analyses.length / cols);
    const cellWidth = canvasSize.width / cols;
    const cellHeight = canvasSize.height / rows;
    const gap = 10;

    analyses.forEach((analysis, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);

      positions.push({
        imageId: analysis.imageId,
        x: col * cellWidth + gap,
        y: row * cellHeight + gap,
        width: cellWidth - gap * 2,
        height: cellHeight - gap * 2,
        rotation: 0,
        zIndex: 1
      });
    });

    return {
      name: 'Grid Layout',
      description: 'æ•´é½çš„ç½‘æ ¼æ’åˆ—',
      positions,
      style: 'grid',
      score: 0
    };
  }

  // è¯„åˆ†ç³»ç»Ÿ
  private scoreLayout(layout: LayoutSuggestion, analyses: PhotoAnalysis[]): number {
    let score = 100;

    layout.positions.forEach(pos => {
      const analysis = analyses.find(a => a.imageId === pos.imageId);
      if (!analysis) return;

      // æ£€æŸ¥é‡è¦å†…å®¹æ˜¯å¦è¢«è£å‰ª
      const imageSafeZone = analysis.safeZone;
      const displayRatio = Math.min(
        pos.width / (imageSafeZone.width + imageSafeZone.x),
        pos.height / (imageSafeZone.height + imageSafeZone.y)
      );

      if (displayRatio < 0.8) {
        score -= 20; // é‡è¦å†…å®¹è¢«è£å‰ª
      }

      // æ£€æŸ¥å®½é«˜æ¯”æ˜¯å¦åˆé€‚
      const aspectRatioDiff = Math.abs(
        (pos.width / pos.height) - analysis.aspectRatio
      );
      if (aspectRatioDiff > 0.5) {
        score -= 10; // å®½é«˜æ¯”å¤±çœŸ
      }
    });

    // æ£€æŸ¥å¸ƒå±€å¹³è¡¡æ€§
    const centerOfMass = this.calculateCenterOfMass(layout.positions);
    const canvasCenter = { x: 0.5, y: 0.5 };
    const balance = 1 - Math.sqrt(
      Math.pow(centerOfMass.x - canvasCenter.x, 2) + 
      Math.pow(centerOfMass.y - canvasCenter.y, 2)
    );
    score += balance * 20;

    return Math.max(0, Math.min(100, score));
  }

  private calculateCenterOfMass(positions: PhotoPosition[]) {
    let totalArea = 0;
    let weightedX = 0;
    let weightedY = 0;

    positions.forEach(pos => {
      const area = pos.width * pos.height;
      totalArea += area;
      weightedX += (pos.x + pos.width / 2) * area;
      weightedY += (pos.y + pos.height / 2) * area;
    });

    return {
      x: weightedX / totalArea,
      y: weightedY / totalArea
    };
  }

  private async extractDominantColors(image: HTMLImageElement): Promise<string[]> {
    // ä½¿ç”¨ Canvas æå–é¢œè‰²
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    canvas.width = 50; // ç¼©å°å°ºå¯¸åŠ å¿«å¤„ç†
    canvas.height = 50;
    ctx.drawImage(image, 0, 0, 50, 50);
    
    const imageData = ctx.getImageData(0, 0, 50, 50);
    const colors = this.quantizeColors(imageData.data, 5);
    
    return colors.map(c => `rgb(${c[0]}, ${c[1]}, ${c[2]})`);
  }

  private quantizeColors(pixels: Uint8ClampedArray, k: number): number[][] {
    // ç®€å•çš„ K-means èšç±»
    const colors: number[][] = [];
    for (let i = 0; i < pixels.length; i += 4) {
      colors.push([pixels[i], pixels[i + 1], pixels[i + 2]]);
    }

    // åˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    let centroids: number[][] = [];
    for (let i = 0; i < k; i++) {
      centroids.push(colors[Math.floor(Math.random() * colors.length)]);
    }

    // K-means è¿­ä»£
    for (let iter = 0; iter < 10; iter++) {
      const clusters: number[][][] = Array(k).fill(null).map(() => []);
      
      colors.forEach(color => {
        let minDist = Infinity;
        let closestIdx = 0;
        
        centroids.forEach((centroid, idx) => {
          const dist = Math.sqrt(
            Math.pow(color[0] - centroid[0], 2) +
            Math.pow(color[1] - centroid[1], 2) +
            Math.pow(color[2] - centroid[2], 2)
          );
          if (dist < minDist) {
            minDist = dist;
            closestIdx = idx;
          }
        });
        
        clusters[closestIdx].push(color);
      });

      // æ›´æ–°èšç±»ä¸­å¿ƒ
      centroids = clusters.map(cluster => {
        if (cluster.length === 0) return centroids[0];
        const sum = cluster.reduce((acc, c) => [acc[0] + c[0], acc[1] + c[1], acc[2] + c[2]], [0, 0, 0]);
        return [
          Math.round(sum[0] / cluster.length),
          Math.round(sum[1] / cluster.length),
          Math.round(sum[2] / cluster.length)
        ];
      });
    }

    return centroids;
  }
}

interface LayoutSuggestion {
  name: string;
  description: string;
  positions: PhotoPosition[];
  style: string;
  score: number;
}

interface PhotoPosition {
  imageId: string;
  x: number;
  y: number;
  width: number;
  height: number;
  rotation: number;
  zIndex: number;
}
```

#### **æ–¹æ¡ˆ B: AI å¢å¼ºï¼ˆè°ƒç”¨ APIï¼‰**

```typescript
// ä½¿ç”¨ GPT-4 Vision è¿›è¡Œæ·±åº¦åˆ†æ
import OpenAI from 'openai';

class AILayoutAssistant {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey, dangerouslyAllowBrowser: true });
  }

  async analyzePhotosWithAI(images: string[]): Promise<any> {
    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `åˆ†æè¿™äº›ç…§ç‰‡çš„å†…å®¹ã€é£æ ¼ã€è‰²è°ƒï¼Œè¿”å› JSON æ ¼å¼ï¼š
              {
                "photos": [
                  {
                    "index": 0,
                    "mainSubject": "äººç‰©/é£æ™¯/ç‰©å“",
                    "mood": "æ¬¢å¿«/å®é™/æ¿€åŠ¨",
                    "colorPalette": ["#hex1", "#hex2"],
                    "composition": "æ¨ªå‘/çºµå‘/æ–¹å½¢",
                    "visualWeight": 0-10 (è§†è§‰é‡é‡)
                  }
                ],
                "overallTheme": "ä¸»é¢˜æè¿°",
                "recommendedLayout": "grid/magazine/focal/golden",
                "reasoning": "æ¨èç†ç”±"
              }`
            },
            ...images.map(base64 => ({
              type: "image_url" as const,
              image_url: { url: base64 }
            }))
          ]
        }
      ],
      max_tokens: 1000
    });

    return JSON.parse(response.choices[0].message.content || '{}');
  }

  // ç»“åˆ AI å»ºè®®å’Œå‡ ä½•ç®—æ³•
  async generateSmartLayout(
    images: HTMLImageElement[],
    canvasSize: { width: number; height: number }
  ) {
    const base64Images = await Promise.all(
      images.map(img => this.imageToBase64(img))
    );

    const aiAnalysis = await this.analyzePhotosWithAI(base64Images);
    
    // æ ¹æ® AI å»ºè®®é€‰æ‹©å¸ƒå±€ç®—æ³•
    const layoutType = aiAnalysis.recommendedLayout;
    const assistant = new LayoutAssistant();
    
    // ... ç»“åˆä½¿ç”¨
  }

  private async imageToBase64(image: HTMLImageElement): Promise<string> {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    ctx.drawImage(image, 0, 0);
    return canvas.toDataURL('image/jpeg', 0.8);
  }
}
```

---

## 5. æ™ºèƒ½è£å‰ª

### ğŸ“‹ å®ç°æ€è·¯

```
åŠ è½½å›¾ç‰‡ â†’ äººè„¸/ç‰©ä½“æ£€æµ‹ â†’ è®¡ç®—æ˜¾è‘—æ€§å›¾ â†’ ç”Ÿæˆè£å‰ªå»ºè®® â†’ ç”¨æˆ·é€‰æ‹©
```

### ğŸ”§ æŠ€æœ¯æ ˆ

```bash
pnmp install face-api.js
pnmp install @mediapipe/tasks-vision
```

```typescript
import * as faceapi from 'face-api.js';

class SmartCrop {
  private isInitialized = false;

  async init() {
    await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
    await faceapi.nets.faceLandmark68Net.loadFromUri('/models');
    this.isInitialized = true;
  }

  // æ™ºèƒ½è£å‰ªä¸»å‡½æ•°
  async suggestCrops(
    image: HTMLImageElement,
    targetAspectRatio: number
  ): Promise<CropSuggestion[]> {
    if (!this.isInitialized) await this.init();

    // 1. æ£€æµ‹äººè„¸
    const faces = await faceapi.detectAllFaces(
      image,
      new faceapi.TinyFaceDetectorOptions()
    ).withFaceLandmarks();

    // 2. è®¡ç®—æ˜¾è‘—æ€§å›¾ï¼ˆä½¿ç”¨è¾¹ç¼˜æ£€æµ‹ï¼‰
    const saliencyMap = await this.calculateSaliencyMap(image);

    // 3. ç”Ÿæˆå¤šä¸ªè£å‰ªå»ºè®®
    const suggestions: CropSuggestion[] = [];

    if (faces.length > 0) {
      // åŸºäºäººè„¸çš„è£å‰ª
      suggestions.push(...this.createFaceCenteredCrops(
        faces,
        image.width,
        image.height,
        targetAspectRatio
      ));
    }

    // åŸºäºæ˜¾è‘—æ€§çš„è£å‰ª
    suggestions.push(...this.createSaliencyCrops(
      saliencyMap,
      image.width,
      image.height,
      targetAspectRatio
    ));

    // ä¸‰åˆ†æ³•è£å‰ª
    suggestions.push(this.createRuleOfThirdsCrop(
      faces.length > 0 ? faces[0] : null,
      image.width,
      image.height,
      targetAspectRatio
    ));

    // æŒ‰è¯„åˆ†æ’åº
    return suggestions
      .map(s => ({ ...s, score: this.scoreCrop(s, faces, saliencyMap) }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 5);
  }

  // ä»¥äººè„¸ä¸ºä¸­å¿ƒçš„è£å‰ª
  private createFaceCenteredCrops(
    faces: faceapi.WithFaceLandmarks<any>[],
    imgWidth: number,
    imgHeight: number,
    targetRatio: number
  ): CropSuggestion[] {
    const suggestions: CropSuggestion[] = [];

    // è®¡ç®—æ‰€æœ‰äººè„¸çš„åŒ…å›´ç›’
    let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
    
    faces.forEach(face => {
      const box = face.detection.box;
      minX = Math.min(minX, box.x);
      minY = Math.min(minY, box.y);
      maxX = Math.max(maxX, box.x + box.width);
      maxY = Math.max(maxY, box.y + box.height);
    });

    const facesWidth = maxX - minX;
    const facesHeight = maxY - minY;
    const facesCenterX = (minX + maxX) / 2;
    const facesCenterY = (minY + maxY) / 2;

    // ç¡®ä¿äººè„¸å æ®åˆç†æ¯”ä¾‹ï¼ˆä¸è¦å¤ªå°ï¼‰
    const minFaceRatio = 0.3; // äººè„¸è‡³å°‘å  30%
    let cropWidth = Math.max(facesWidth / minFaceRatio, facesHeight * targetRatio);
    let cropHeight = cropWidth / targetRatio;

    // è°ƒæ•´åˆ°å›¾ç‰‡è¾¹ç•Œå†…
    cropWidth = Math.min(cropWidth, imgWidth);
    cropHeight = Math.min(cropHeight, imgHeight);

    // å±…ä¸­è£å‰ª
    let x = facesCenterX - cropWidth / 2;
    let y = facesCenterY - cropHeight / 2;

    // è¾¹ç•Œæ£€æŸ¥
    x = Math.max(0, Math.min(x, imgWidth - cropWidth));
    y = Math.max(0, Math.min(y, imgHeight - cropHeight));

    suggestions.push({
      name: 'Face Centered',
      description: `åŒ…å« ${faces.length} å¼ äººè„¸`,
      x, y,
      width: cropWidth,
      height: cropHeight,
      score: 0
    });

    // å¦‚æœåªæœ‰ä¸€å¼ è„¸ï¼Œæ·»åŠ ç‰¹å†™è£å‰ª
    if (faces.length === 1) {
      const face = faces[0].detection.box;
      const closeupWidth = face.width * 2;
      const closeupHeight = closeupWidth / targetRatio;

      suggestions.push({
        name: 'Portrait Close-up',
        description: 'äººåƒç‰¹å†™',
        x: Math.max(0, face.x + face.width / 2 - closeupWidth / 2),
        y: Math.max(0, face.y - closeupHeight * 0.2), // ç¨å¾®å¾€ä¸Šï¼Œç•™å‡ºå¤´éƒ¨ç©ºé—´
        width: Math.min(closeupWidth, imgWidth),
        height: Math.min(closeupHeight, imgHeight),
        score: 0
      });
    }

    return suggestions;
  }

  // ä¸‰åˆ†æ³•è£å‰ª
  private createRuleOfThirdsCrop(
    primaryFace: faceapi.WithFaceLandmarks<any> | null,
    imgWidth: number,
    imgHeight: number,
    targetRatio: number
  ): CropSuggestion {
    const cropWidth = Math.min(imgWidth, imgHeight * targetRatio);
    const cropHeight = cropWidth / targetRatio;

    let centerX = imgWidth / 2;
    let centerY = imgHeight / 2;

    if (primaryFace) {
      const box = primaryFace.detection.box;
      centerX = box.x + box.width / 2;
      centerY = box.y + box.height / 2;
    }

    // å°†ä¸­å¿ƒç‚¹æ”¾åœ¨ä¸‰åˆ†çº¿ä¸Š
    const thirdX = Math.round(centerX / (imgWidth / 3)) * (imgWidth / 3);
    const thirdY = Math.round(centerY / (imgHeight / 3)) * (imgHeight / 3);

    return {
      name: 'Rule of Thirds',
      description: 'ç¬¦åˆä¸‰åˆ†æ³•æ„å›¾',
      x: Math.max(0, Math.min(thirdX - cropWidth / 2, imgWidth - cropWidth)),
      y: Math.max(0, Math.min(thirdY - cropHeight / 2, imgHeight - cropHeight)),
      width: cropWidth,
      height: cropHeight,
      score: 0
    };
  }

  // è®¡ç®—æ˜¾è‘—æ€§å›¾ï¼ˆç®€åŒ–ç‰ˆï¼‰
  private async calculateSaliencyMap(image: HTMLImageElement): Promise<number[][]> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const size = 100; // é™ä½åˆ†è¾¨ç‡åŠ å¿«è®¡ç®—
    canvas.width = size;
    canvas.height = size;
    
    ctx.drawImage(image, 0, 0, size, size);
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    const saliencyMap: number[][] = Array(size).fill(0).map(() => Array(size).fill(0));

    // ä½¿ç”¨è¾¹ç¼˜æ£€æµ‹ + å¯¹æ¯”åº¦è®¡ç®—æ˜¾è‘—æ€§
    for (let y = 1; y < size - 1; y++) {
      for (let x = 1; x < size - 1; x++) {
        const idx = (y * size + x) * 4;
        
        // Sobel è¾¹ç¼˜æ£€æµ‹
        const gx = 
          -data[idx - 4 - size * 4] + data[idx + 4 - size * 4] +
          -2 * data[idx - 4] + 2 * data[idx + 4] +
          -data[idx - 4 + size * 4] + data[idx + 4 + size * 4];
        
        const gy =
          -data[idx - size * 4 - 4] - 2 * data[idx - size * 4] - data[idx - size * 4 + 4] +
          data[idx + size * 4 - 4] + 2 * data[idx + size * 4] + data[idx + size * 4 + 4];
        
        saliencyMap[y][x] = Math.sqrt(gx * gx + gy * gy);
      }
    }

    return saliencyMap;
  }

  // åŸºäºæ˜¾è‘—æ€§çš„è£å‰ª
  private createSaliencyCrops(
    saliencyMap: number[][],
    imgWidth: number,
    imgHeight: number,
    targetRatio: number
  ): CropSuggestion[] {
    const mapHeight = saliencyMap.length;
    const mapWidth = saliencyMap[0].length;

    // æ‰¾åˆ°æ˜¾è‘—æ€§æœ€é«˜çš„åŒºåŸŸ
    let maxSaliency = 0;
    let maxX = 0, maxY = 0;

    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        if (saliencyMap[y][x] > maxSaliency) {
          maxSaliency = saliencyMap[y][x];
          maxX = x;
          maxY = y;
        }
      }
    }

    // è½¬æ¢åˆ°åŸå›¾åæ ‡
    const centerX = (maxX / mapWidth) * imgWidth;
    const centerY = (maxY / mapHeight) * imgHeight;

    const cropWidth = Math.min(imgWidth * 0.8, imgHeight * 0.8 * targetRatio);
    const cropHeight = cropWidth / targetRatio;

    return [{
      name: 'Content Focused',
      description: 'èšç„¦æ˜¾è‘—å†…å®¹',
      x: Math.max(0, Math.min(centerX - cropWidth / 2, imgWidth - cropWidth)),
      y: Math.max(0, Math.min(centerY - cropHeight / 2, imgHeight - cropHeight)),
      width: cropWidth,
      height: cropHeight,
      score: 0
    }];
  }

  // è¯„åˆ†ç³»ç»Ÿ
  private scoreCrop(
    crop: CropSuggestion,
    faces: faceapi.WithFaceLandmarks<any>[],
    saliencyMap: number[][]
  ): number {
    let score = 50;

    // äººè„¸å®Œæ•´æ€§
    faces.forEach(face => {
      const box = face.detection.box;
      const faceArea = box.width * box.height;
      const visibleArea = this.calculateOverlap(
        { x: box.x, y: box.y, width: box.width, height: box.height },
        crop
      );
      const faceRatio = visibleArea / faceArea;
      
      if (faceRatio > 0.9) score += 30; // å®Œæ•´æ˜¾ç¤º
      else if (faceRatio > 0.7) score += 15;
      else score -= 20; // äººè„¸è¢«è£å‰ª
    });

    // æ˜¾è‘—æ€§è¦†ç›–
    const mapHeight = saliencyMap.length;
    const mapWidth = saliencyMap[0].length;
    let totalSaliency = 0;
    let cropSaliency = 0;

    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const val = saliencyMap[y][x];
        totalSaliency += val;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨è£å‰ªåŒºåŸŸå†…
        const imgX = (x / mapWidth) * crop.width + crop.x;
        const imgY = (y / mapHeight) * crop.height + crop.y;
        if (imgX >= crop.x && imgX <= crop.x + crop.width &&
            imgY >= crop.y && imgY <= crop.y + crop.height) {
          cropSaliency += val;
        }
      }
    }

    score += (cropSaliency / totalSaliency) * 20;

    return Math.max(0, Math.min(100, score));
  }

  private calculateOverlap(rect1: any, rect2: any): number {
    const x1 = Math.max(rect1.x, rect2.x);
    const y1 = Math.max(rect1.y, rect2.y);
    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);

    if (x2 <= x1 || y2 <= y1) return 0;
    return (x2 - x1) * (y2 - y1);
  }
}

interface CropSuggestion {
  name: string;
  description: string;
  x: number;
  y: number;
  width: number;
  height: number;
  score: number;
}
```

---

## 6. è‰²å½©åè°ƒ

### ğŸ“‹ å®ç°æ€è·¯

```
æå–ä¸»è‰²è°ƒ â†’ è‰²å½©ç†è®ºåˆ†æ â†’ ç”Ÿæˆé…è‰²æ–¹æ¡ˆ â†’ è‡ªåŠ¨è°ƒæ•´
```

### ğŸ”§ æŠ€æœ¯æ ˆ

```bash
pnmp install color
pnmp install chroma-js
```

```typescript
import chroma from 'chroma-js';
import Color from 'color';

class ColorHarmony {
  // æå–ç…§ç‰‡ä¸»è‰²è°ƒ
  async extractPalette(image: HTMLImageElement, numColors: number = 5): Promise<string[]> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const size = 100;
    canvas.width = size;
    canvas.height = size;
    
    ctx.drawImage(image, 0, 0, size, size);
    const imageData = ctx.getImageData(0, 0, size, size);
    
    // ä½¿ç”¨ä¸­ä½åˆ‡åˆ†ç®—æ³•ï¼ˆæ¯” K-means æ›´å¿«ï¼‰
    const colors = this.medianCut(imageData.data, numColors);
    
    return colors.map(c => chroma(c).hex());
  }

  // ä¸­ä½åˆ‡åˆ†ç®—æ³•
  private medianCut(pixels: Uint8ClampedArray, targetColors: number): number[][] {
    const colors: number[][] = [];
    
    for (let i = 0; i < pixels.length; i += 4) {
      // è·³è¿‡é€æ˜å’Œæ¥è¿‘ç™½è‰²/é»‘è‰²çš„åƒç´ 
      if (pixels[i + 3] < 125) continue;
      const brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
      if (brightness > 250 || brightness < 5) continue;
      
      colors.push([pixels[i], pixels[i + 1], pixels[i + 2]]);
    }

    const buckets = [colors];
    
    while (buckets.length < targetColors) {
      // æ‰¾åˆ°æœ€å¤§çš„æ¡¶
      buckets.sort((a, b) => b.length - a.length);
      const bucket = buckets.shift()!;
      
      // æ‰¾åˆ°é¢œè‰²èŒƒå›´æœ€å¤§çš„é€šé“
      const ranges = this.getColorRanges(bucket);
      const maxChannel = ranges.indexOf(Math.max(...ranges));
      
      // æŒ‰è¯¥é€šé“æ’åº
      bucket.sort((a, b) => a[maxChannel] - b[maxChannel]);
      
      // ä»ä¸­ä½æ•°åˆ†å‰²
      const median = Math.floor(bucket.length / 2);
      buckets.push(bucket.slice(0, median));
      buckets.push(bucket.slice(median));
    }

    // è®¡ç®—æ¯ä¸ªæ¡¶çš„å¹³å‡é¢œè‰²
    return buckets.map(bucket => {
      const sum = bucket.reduce(
        (acc, c) => [acc[0] + c[0], acc[1] + c[1], acc[2] + c[2]],
        [0, 0, 0]
      );
      return [
        Math.round(sum[0] / bucket.length),
        Math.round(sum[1] / bucket.length),
        Math.round(sum[2] / bucket.length)
      ];
    });
  }

  private getColorRanges(colors: number[][]): number[] {
    const mins = [255, 255, 255];
    const maxs = [0, 0, 0];
    
    colors.forEach(c => {
      for (let i = 0; i < 3; i++) {
        mins[i] = Math.min(mins[i], c[i]);
        maxs[i] = Math.max(maxs[i], c[i]);
      }
    });
    
    return [maxs[0] - mins[0], maxs[1] - mins[1], maxs[2] - mins[2]];
  }

  // åˆ†æå¤šå¼ ç…§ç‰‡çš„æ•´ä½“è‰²è°ƒ
  async analyzeMultiplePhotos(images: HTMLImageElement[]): Promise<ColorAnalysis> {
    const palettes = await Promise.all(
      images.map(img => this.extractPalette(img, 3))
    );

    // åˆå¹¶æ‰€æœ‰é¢œè‰²
    const allColors = palettes.flat();
    
    // è®¡ç®—å¹³å‡è‰²ç›¸ã€é¥±å’Œåº¦ã€æ˜åº¦
    const hslValues = allColors.map(c => {
      const color = Color(c);
      return {
        h: color.hue(),
        s: color.saturationl(),
        l: color.lightness()
      };
    });

    const avgHue = hslValues.reduce((sum, c) => sum + c.h, 0) / hslValues.length;
    const avgSat = hslValues.reduce((sum, c) => sum + c.s, 0) / hslValues.length;
    const avgLight = hslValues.reduce((sum, c) => sum + c.l, 0) / hslValues.length;

    // åˆ¤æ–­è‰²è°ƒç±»å‹
    const colorScheme = this.detectColorScheme(hslValues);

    return {
      dominantColors: this.findDominantColors(allColors, 5),
      averageHue: avgHue,
      averageSaturation: avgSat,
      averageLightness: avgLight,
      colorScheme,
      mood: this.detectMood(avgHue, avgSat, avgLight)
    };
  }

  // æ£€æµ‹é…è‰²æ–¹æ¡ˆç±»å‹
  private detectColorScheme(colors: Array<{ h: number; s: number; l: number }>): string {
    const hues = colors.map(c => c.h);
    const saturations = colors.map(c => c.s);
    
    // å•è‰²è°ƒ
    const hueVariance = this.variance(hues);
    if (hueVariance < 900) return 'monochromatic';
    
    // ç±»æ¯”è‰²
    if (hueVariance < 3600) return 'analogous';
    
    // å¯¹æ¯”è‰²
    const hasComplement = hues.some((h1, i) => 
      hues.slice(i + 1).some(h2 => Math.abs(h1 - h2 - 180) < 30)
    );
    if (hasComplement) return 'complementary';
    
    // ä¸‰è§’è‰²
    const hasTriadic = hues.some((h1, i) => 
      hues.slice(i + 1).some(h2 => Math.abs(h1 - h2 - 120) < 30)
    );
    if (hasTriadic) return 'triadic';
    
    return 'polychromatic';
  }

  private variance(numbers: number[]): number {
    const avg = numbers.reduce((a, b) => a + b, 0) / numbers.length;
    return numbers.reduce((sum, n) => sum + Math.pow(n - avg, 2), 0) / numbers.length;
  }

  // æ ¹æ®è‰²è°ƒåˆ¤æ–­æƒ…ç»ª
  private detectMood(hue: number, sat: number, light: number): string {
    if (light > 70) {
      return sat > 50 ? 'energetic' : 'peaceful';
    } else if (light < 30) {
      return sat > 50 ? 'dramatic' : 'somber';
    } else {
      if (hue >= 0 && hue < 60) return 'warm'; // çº¢-é»„
      if (hue >= 180 && hue < 270) return 'cool'; // è“-é’
      if (hue >= 60 && hue < 180) return 'fresh'; // ç»¿
      return 'romantic'; // ç´«-å“çº¢
    }
  }

  // ç”Ÿæˆå’Œè°çš„è¾¹æ¡†/èƒŒæ™¯è‰²
  generateHarmoniousColors(baseColors: string[]): ColorSuggestions {
    const mainColor = chroma(baseColors[0]);
    
    return {
      backgrounds: {
        light: mainColor.brighten(3).desaturate(2).hex(),
        dark: mainColor.darken(3).hex(),
        neutral: chroma.mix(mainColor, '#808080', 0.8).hex(),
        gradient: [
          mainColor.brighten(2).hex(),
          mainColor.darken(1).hex()
        ]
      },
      borders: {
        complementary: chroma.hsl(
          (mainColor.get('hsl.h') + 180) % 360,
          mainColor.get('hsl.s'),
          mainColor.get('hsl.l')
        ).hex(),
        analogous: [
          chroma.hsl((mainColor.get('hsl.h') + 30) % 360, mainColor.get('hsl.s'), mainColor.get('hsl.l')).hex(),
          chroma.hsl((mainColor.get('hsl.h') - 30 + 360) % 360, mainColor.get('hsl.s'), mainColor.get('hsl.l')).hex()
        ],
        monochromatic: [
          mainColor.brighten(1).hex(),
          mainColor.darken(1).hex()
        ]
      },
      accents: this.generateAccentColors(baseColors)
    };
  }

  private generateAccentColors(baseColors: string[]): string[] {
    return baseColors.map(color => {
      const c = chroma(color);
      // å¢åŠ é¥±å’Œåº¦å’Œå¯¹æ¯”åº¦
      return c.saturate(2).hex();
    });
  }

  private findDominantColors(colors: string[], count: number): string[] {
    // ç®€å•çš„é¢‘ç‡ç»Ÿè®¡ï¼ˆå¯ä»¥ä¼˜åŒ–ä¸ºæ›´å¤æ‚çš„èšç±»ï¼‰
    const colorMap = new Map<string, number>();
    
    colors.forEach(color => {
      const normalized = chroma(color).hex();
      colorMap.set(normalized, (colorMap.get(normalized) || 0) + 1);
    });

    return Array.from(colorMap.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, count)
      .map(([color]) => color);
  }

  // è‡ªåŠ¨è°ƒæ•´ç…§ç‰‡è‰²å½©ä½¿å…¶åè°ƒ
  async harmonizePhotos(
    images: HTMLImageElement[],
    targetStyle: 'warm' | 'cool' | 'vibrant' | 'muted' | 'unified'
  ): Promise<HTMLCanvasElement[]> {
    const canvases: HTMLCanvasElement[] = [];

    for (const img of images) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      canvas.width = img.width;
      canvas.height = img.height;
      
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // åº”ç”¨è‰²å½©è°ƒæ•´
      for (let i = 0; i < data.length; i += 4) {
        const color = Color.rgb(data[i], data[i + 1], data[i + 2]);
        let adjusted: Color;

        switch (targetStyle) {
          case 'warm':
            adjusted = color.rotate(10).saturate(0.1);
            break;
          case 'cool':
            adjusted = color.rotate(-10).saturate(0.1);
            break;
          case 'vibrant':
            adjusted = color.saturate(0.3);
            break;
          case 'muted':
            adjusted = color.desaturate(0.3);
            break;
          case 'unified':
            // ç»Ÿä¸€åˆ°å¹³å‡è‰²è°ƒ
            const avgColor = Color.hsl(180, 50, 50); // ç¤ºä¾‹
            adjusted = Color.rgb(
              data[i] * 0.7 + avgColor.red() * 0.3,
              data[i + 1] * 0.7 + avgColor.green() * 0.3,
              data[i + 2] * 0.7 + avgColor.blue() * 0.3
            );
            break;
        }

        data[i] = adjusted.red();
        data[i + 1] = adjusted.green();
        data[i + 2] = adjusted.blue();
      }

      ctx.putImageData(imageData, 0, 0);
      canvases.push(canvas);
    }

    return canvases;
  }
}

interface ColorAnalysis {
  dominantColors: string[];
  averageHue: number;
  averageSaturation: number;
  averageLightness: number;
  colorScheme: string;
  mood: string;
}

interface ColorSuggestions {
  backgrounds: {
    light: string;
    dark: string;
    neutral: string;
    gradient: string[];
  };
  borders: {
    complementary: string;
    analogous: string[];
    monochromatic: string[];
  };
  accents: string[];
}
```

---

## ğŸ“¦ å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

```vue
<template>
  <div class="smart-layout-panel">
    <div class="layout-suggestions">
      <h3>ğŸ¨ AI å¸ƒå±€å»ºè®®</h3>
      <div 
        v-for="layout in layouts" 
        :key="layout.name"
        class="layout-card"
        :class="{ selected: selectedLayout === layout }"
        @click="applyLayout(layout)"
      >
        <div class="layout-preview">
          <svg :viewBox="`0 0 ${canvasSize.width} ${canvasSize.height}`">
            <rect 
              v-for="pos in layout.positions" 
              :key="pos.imageId"
              :x="pos.x" 
              :y="pos.y"
              :width="pos.width" 
              :height="pos.height"
              :transform="`rotate(${pos.rotation} ${pos.x + pos.width/2} ${pos.y + pos.height/2})`"
              fill="rgba(99, 102, 241, 0.3)"
              stroke="#6366f1"
              stroke-width="2"
            />
          </svg>
        </div>
        <div class="layout-info">
          <h4>{{ layout.name }}</h4>
          <p>{{ layout.description }}</p>
          <div class="score">è¯„åˆ†: {{ Math.round(layout.score) }}/100</div>
        </div>
      </div>
    </div>

    <div class="crop-suggestions">
      <h3>âœ‚ï¸ æ™ºèƒ½è£å‰ªå»ºè®®</h3>
      <div v-for="crop in crops" :key="crop.name" class="crop-card">
        <canvas ref="cropPreview" :width="200" :height="200"></canvas>
        <button @click="applyCrop(crop)">{{ crop.name }}</button>
      </div>
    </div>

    <div class="color-harmony">
      <h3>ğŸ¨ è‰²å½©åè°ƒ</h3>
      <div class="color-analysis">
        <div class="palette">
          <div 
            v-for="color in colorAnalysis.dominantColors" 
            :key="color"
            class="color-swatch"
            :style="{ backgroundColor: color }"
          ></div>
        </div>
        <p>é…è‰²ç±»å‹: {{ colorAnalysis.colorScheme }}</p>
        <p>æƒ…ç»ª: {{ colorAnalysis.mood }}</p>
      </div>

      <div class="color-suggestions">
        <h4>æ¨èèƒŒæ™¯è‰²</h4>
        <div class="suggestion-group">
          <div 
            v-for="(bg, key) in colorSuggestions.backgrounds"
            :key="key"
            class="color-option"
            :style="{ backgroundColor: Array.isArray(bg) ? bg[0] : bg }"
            @click="applyBackground(bg)"
          >
            {{ key }}
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';

const layoutAssistant = new LayoutAssistant();
const smartCrop = new SmartCrop();
const colorHarmony = new ColorHarmony();

const layouts = ref<LayoutSuggestion[]>([]);
const crops = ref<CropSuggestion[]>([]);
const colorAnalysis = ref<ColorAnalysis | null>(null);
const colorSuggestions = ref<ColorSuggestions | null>(null);
const selectedLayout = ref<LayoutSuggestion | null>(null);

const canvasSize = ref({ width: 1200, height: 800 });

async function analyzePhotos(images: HTMLImageElement[]) {
  // 1. åˆ†ææ¯å¼ ç…§ç‰‡
  const analyses = await Promise.all(
    images.map(img => layoutAssistant.analyzePhoto(img))
  );

  // 2. ç”Ÿæˆå¸ƒå±€å»ºè®®
  layouts.value = layoutAssistant.generateLayouts(analyses, canvasSize.value);

  // 3. ç”Ÿæˆè£å‰ªå»ºè®®ï¼ˆé’ˆå¯¹ç¬¬ä¸€å¼ ç…§ç‰‡ç¤ºä¾‹ï¼‰
  if (images.length > 0) {
    crops.value = await smartCrop.suggestCrops(images[0], 16/9);
  }

  // 4. è‰²å½©åˆ†æ
  colorAnalysis.value = await colorHarmony.analyzeMultiplePhotos(images);
  
  if (colorAnalysis.value) {
    colorSuggestions.value = colorHarmony.generateHarmoniousColors(
      colorAnalysis.value.dominantColors
    );
  }
}

function applyLayout(layout: LayoutSuggestion) {
  selectedLayout.value = layout;
  // åº”ç”¨å¸ƒå±€åˆ°ç”»å¸ƒ...
  emit('layoutApplied', layout);
}

function applyCrop(crop: CropSuggestion) {
  emit('cropApplied', crop);
}

function applyBackground(color: string | string[]) {
  emit('backgroundChanged', color);
}

// æš´éœ²ç»™çˆ¶ç»„ä»¶è°ƒç”¨
defineExpose({ analyzePhotos });
</script>

<style scoped>
.smart-layout-panel {
  padding: 20px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 16px;
  backdrop-filter: blur(10px);
}

.layout-card {
  cursor: pointer;
  padding: 15px;
  border: 2px solid transparent;
  border-radius: 12px;
  transition: all 0.3s;
}

.layout-card:hover {
  border-color: #6366f1;
  background: rgba(99, 102, 241, 0.1);
}

.layout-card.selected {
  border-color: #6366f1;
  background: rgba(99, 102, 241, 0.2);
}

.color-swatch {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  border: 2px solid rgba(255, 255, 255, 0.2);
}
</style>
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. **Web Worker å¼‚æ­¥å¤„ç†**
```typescript
// worker.ts
import { LayoutAssistant } from './layoutAssistant';

self.onmessage = async (e) => {
  const { images, canvasSize } = e.data;
  const assistant = new LayoutAssistant();
  
  const result = await assistant.generateLayouts(images, canvasSize);
  self.postMessage(result);
};
```

### 2. **æ¸è¿›å¼åŠ è½½**
```typescript
// å…ˆæ˜¾ç¤ºå¿«é€Ÿç®—æ³•ç»“æœï¼Œå†ç”¨ AI ä¼˜åŒ–
async function progressiveAnalysis(images: HTMLImageElement[]) {
  // ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€å‡ ä½•å¸ƒå±€ï¼ˆ< 100msï¼‰
  const quickLayouts = generateQuickLayouts(images);
  emit('layoutsReady', quickLayouts);
  
  // ç¬¬äºŒé˜¶æ®µï¼šAI åˆ†æï¼ˆ1-2sï¼‰
  const aiLayouts = await generateAILayouts(images);
  emit('layoutsUpdated', aiLayouts);
}
```

### 3. **ç¼“å­˜ç­–ç•¥**
```typescript
const analysisCache = new Map<string, PhotoAnalysis>();

async function analyzeWithCache(image: HTMLImageElement) {
  const hash = await imageHash(image);
  
  if (analysisCache.has(hash)) {
    return analysisCache.get(hash)!;
  }
  
  const analysis = await layoutAssistant.analyzePhoto(image);
  analysisCache.set(hash, analysis);
  return analysis;
}
```

---

## ğŸ¯ æ€»ç»“

| åŠŸèƒ½ | å‰ç«¯åº“ | API æœåŠ¡ | éš¾åº¦ | æ•ˆæœ |
|------|--------|---------|------|------|
| AI å¸ƒå±€åŠ©æ‰‹ | TensorFlow.js, COCO-SSD | GPT-4 Vision | â­â­â­ | â­â­â­â­ |
| æ™ºèƒ½è£å‰ª | face-api.js | - | â­â­ | â­â­â­â­ |
| è‰²å½©åè°ƒ | chroma-js, color | - | â­ | â­â­â­ |

**å…ˆå®ç°è‰²å½©åè°ƒ**ï¼ˆæœ€ç®€å•ï¼‰ï¼Œå†åš**æ™ºèƒ½è£å‰ª**ï¼ˆæ•ˆæœæ˜æ˜¾ï¼‰ï¼Œæœ€åæ•´åˆ**AI å¸ƒå±€åŠ©æ‰‹**ï¼ˆæœ€å¤æ‚ä½†æœ€æœ‰ä»·å€¼ï¼‰ã€‚